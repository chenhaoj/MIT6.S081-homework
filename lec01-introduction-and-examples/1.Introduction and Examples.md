操作系统结构：

这门课主要关注点在Kernel、连接Kernel和用户程序的接口、Kernel内软件的架构。我们关心Kernel中的服务，其中一个服务是**文件系统**，另一个就是**进程管理系统**。**每一个用户空间程序都被称为一个进程**，它们有自己的内存和共享的CPU时间。同时，Kernel会**管理内存的分配**。不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。



文件描述符：

文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。



系统调用：

- fork：fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。fork创建了一个新的进程。当我们在Shell中运行东西的时候，Shell实际上会创建一个新的进程来运行你输入的每一个指令。所以，当我输入ls时，我们需要Shell通过fork创建一个进程来运行ls，这里需要某种方式来让这个新的进程来运行ls程序中的指令，加载名为ls的文件中的指令（也就是后面的exec系统调用）。
- exec：这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。

注意：我们不会希望Shell执行exec系统调用，因为exec在执行完毕后不会返回。实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。即，对于还希望能拿回控制权的场景，可以先调用fork系统调用，然后在子进程中调用exec。

- wait：是一种让退出的子进程以一个整数（32bit的数据）的格式与等待的父进程通信方式。wait(&status)，是将status对应的地址传递给内核，内核将会向这个地址写入子进程向exit传入的参数。



Q & A：

- 什么是系统调用？系统调用和普通的函数区别在哪里？

  系统调用需要进入到内核，经过一系列处理之后再从内核返回用户。系统调用不一定是函数，也可以只是其它一些简单的指令。只是为了可复用，因此封装成了函数，实际上本质只是一个代码块。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。

- 为什么要给xv6添加用户程序？

  因为我们作为系统的使用者，所作的一些操作比如cat \ grep等等都是应用程序，而不是系统程序。系统程序是系统的开发人员才需要管理的，因此要给xv6添加用户程序。

- 如何理解shell？

  因为操作系统在启动的时候是有三级还是几级启动，如果是最低级的启动就是我们印象中shell的那种命令行交互窗口，实际上更高级的显示界面也是一种shell，只是启动等级不同。那么shell实际上是什么呢？在xv6/user/sh.c也就是shell的源文件中可以看到，实际上是一个循环，在循环中启动一个console文件，然后对每一次输入做一次fork然后run，简单意义上来说就是一直重复循环。

- 为什么一台电脑既可以装windows也可以装Linux还可以装黑苹果？

  因为操作系统实际上也是一堆记录在磁盘上的代码文件，而这些代码的执行需要硬件指令集的支持。目前常见的指令集架构有x86和arm两种，只要cpu支持x86，那么就能够装x86的一切系统。另一个需要注意的点是，装多个操作系统的差别实际上只是引导程序的不同，怎样设置引导程序才是比较重要的事情。

- 

